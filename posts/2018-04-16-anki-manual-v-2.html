<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="谭 长德">
<meta name="dcterms.date" content="2018-04-16">

<title>万物尺度 - Anki 2.0 用户指南</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../android-chrome-512x512.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1YFYY3SM29"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1YFYY3SM29', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="万物尺度 - Anki 2.0 用户指南">
<meta property="og:description" content="">
<meta property="og:site-name" content="万物尺度">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">万物尺度</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#介绍视频" id="toc-介绍视频" class="nav-link active" data-scroll-target="#介绍视频">介绍视频</a></li>
  <li><a href="#其他语言版本指南" id="toc-其他语言版本指南" class="nav-link" data-scroll-target="#其他语言版本指南">其他语言版本指南</a></li>
  <li><a href="#简介" id="toc-简介" class="nav-link" data-scroll-target="#简介">简介</a>
  <ul class="collapse">
  <li><a href="#主动回忆测试" id="toc-主动回忆测试" class="nav-link" data-scroll-target="#主动回忆测试">主动回忆测试</a></li>
  <li><a href="#用进废退" id="toc-用进废退" class="nav-link" data-scroll-target="#用进废退">用进废退</a></li>
  <li><a href="#间隔重复" id="toc-间隔重复" class="nav-link" data-scroll-target="#间隔重复">间隔重复</a></li>
  <li><a href="#为什么选择-anki" id="toc-为什么选择-anki" class="nav-link" data-scroll-target="#为什么选择-anki">为什么选择 Anki ？</a></li>
  </ul></li>
  <li><a href="#核心术语" id="toc-核心术语" class="nav-link" data-scroll-target="#核心术语">核心术语</a>
  <ul class="collapse">
  <li><a href="#卡片cards" id="toc-卡片cards" class="nav-link" data-scroll-target="#卡片cards">卡片（Cards）</a></li>
  <li><a href="#卡组decks" id="toc-卡组decks" class="nav-link" data-scroll-target="#卡组decks">卡组（Decks）</a></li>
  <li><a href="#笔记与字段notes-fields" id="toc-笔记与字段notes-fields" class="nav-link" data-scroll-target="#笔记与字段notes-fields">笔记与字段（Notes &amp; Fields）</a></li>
  <li><a href="#卡片类型card-types" id="toc-卡片类型card-types" class="nav-link" data-scroll-target="#卡片类型card-types">卡片类型（Card Types）</a></li>
  <li><a href="#笔记类型note-types" id="toc-笔记类型note-types" class="nav-link" data-scroll-target="#笔记类型note-types">笔记类型（Note Types）</a></li>
  <li><a href="#集合collection" id="toc-集合collection" class="nav-link" data-scroll-target="#集合collection">集合（Collection）</a></li>
  </ul></li>
  <li><a href="#添加学习内容" id="toc-添加学习内容" class="nav-link" data-scroll-target="#添加学习内容">添加学习内容</a>
  <ul class="collapse">
  <li><a href="#下载共享卡组" id="toc-下载共享卡组" class="nav-link" data-scroll-target="#下载共享卡组">下载共享卡组</a></li>
  <li><a href="#添加卡片与笔记" id="toc-添加卡片与笔记" class="nav-link" data-scroll-target="#添加卡片与笔记">添加卡片与笔记</a></li>
  <li><a href="#添加笔记类型" id="toc-添加笔记类型" class="nav-link" data-scroll-target="#添加笔记类型">添加笔记类型</a></li>
  <li><a href="#定制字段" id="toc-定制字段" class="nav-link" data-scroll-target="#定制字段">定制字段</a></li>
  <li><a href="#更改卡组或笔记类型" id="toc-更改卡组或笔记类型" class="nav-link" data-scroll-target="#更改卡组或笔记类型">更改卡组或笔记类型</a></li>
  <li><a href="#恰当使用卡组" id="toc-恰当使用卡组" class="nav-link" data-scroll-target="#恰当使用卡组">恰当使用卡组</a></li>
  </ul></li>
  <li><a href="#学习" id="toc-学习" class="nav-link" data-scroll-target="#学习">学习</a>
  <ul class="collapse">
  <li><a href="#卡组" id="toc-卡组" class="nav-link" data-scroll-target="#卡组">卡组</a></li>
  <li><a href="#学习概览" id="toc-学习概览" class="nav-link" data-scroll-target="#学习概览">学习概览</a></li>
  <li><a href="#题目" id="toc-题目" class="nav-link" data-scroll-target="#题目">题目</a></li>
  <li><a href="#学习-1" id="toc-学习-1" class="nav-link" data-scroll-target="#学习-1">学习</a></li>
  <li><a href="#复习" id="toc-复习" class="nav-link" data-scroll-target="#复习">复习</a></li>
  <li><a href="#到期计数和时间估计" id="toc-到期计数和时间估计" class="nav-link" data-scroll-target="#到期计数和时间估计">到期计数和时间估计</a></li>
  <li><a href="#编辑及更多" id="toc-编辑及更多" class="nav-link" data-scroll-target="#编辑及更多">编辑及更多</a></li>
  <li><a href="#展示顺序" id="toc-展示顺序" class="nav-link" data-scroll-target="#展示顺序">展示顺序</a></li>
  <li><a href="#姊妹卡与搁置" id="toc-姊妹卡与搁置" class="nav-link" data-scroll-target="#姊妹卡与搁置">姊妹卡与搁置</a></li>
  <li><a href="#快捷键" id="toc-快捷键" class="nav-link" data-scroll-target="#快捷键">快捷键</a></li>
  <li><a href="#滞后" id="toc-滞后" class="nav-link" data-scroll-target="#滞后">滞后</a></li>
  </ul></li>
  <li><a href="#change-log" id="toc-change-log" class="nav-link" data-scroll-target="#change-log">Change Log</a></li>
  <li><a href="#许可声明" id="toc-许可声明" class="nav-link" data-scroll-target="#许可声明">许可声明</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anki 2.0 用户指南</h1>
  <div class="quarto-categories">
    <div class="quarto-category">学习工具</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>谭 长德 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 16, 2018</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="介绍视频" class="level2">
<h2 class="anchored" data-anchor-id="介绍视频">介绍视频</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=QS2G-k2hQyg&amp;yt%3Acc=on">共享卡组与复习基本操作</a></li>
<li><a href="https://www.youtube.com/watch?v=DnbKwHEQ1mA&amp;yt%3Acc=on">切换卡片顺序</a></li>
<li><a href="https://www.youtube.com/watch?v=F1j1Zx0mXME&amp;yt%3Acc=on">设计卡片样式</a></li>
<li><a href="https://www.youtube.com/watch?v=5tYObQ3ocrw&amp;yt%3Acc=on">在回答中输入</a></li>
</ul>
<p>如果 YouTube 无法正常访问，可<a href="https://apps.ankiweb.net/downloads/archive/screencasts/2.0/">在此</a>下载以上视频。</p>
</section>
<section id="其他语言版本指南" class="level2">
<h2 class="anchored" data-anchor-id="其他语言版本指南">其他语言版本指南</h2>
<p>本指南还被翻译为以下语言：</p>
<ul>
<li><a href="https://apps.ankiweb.net/docs/manual.id.html">Bahasa Indonesia</a></li>
<li><a href="http://www.dennisproksch.de/anki">Deutsch</a></li>
<li><a href="https://apps.ankiweb.net/docs/manual.es.html">Español</a></li>
<li><a href="https://apps.ankiweb.net/docs/manual.fr.html">Français</a></li>
<li><a href="https://web.archive.org/web/20160423223801/http://192.167.9.6/Anki_ITA/Manual_ITA.htm">Italiano</a></li>
<li><a href="https://apps.ankiweb.net/docs/manual.pl.html">Polski</a></li>
<li><a href="http://ankidroid.ir/anki.pdf">فارسى</a></li>
<li><a href="http://wikiwiki.jp/rage2050/?FrontPage">日本語</a></li>
<li><a href="https://apps.ankiweb.net/docs/manual20.html">English</a></li>
<li><a href="http://finpapa.ucoz.ru/ankitest-manual.html">по-русски</a></li>
</ul>
<p>以上译文由志愿者无偿提供。如果你想将本指南翻译为其他语言，或查看有哪些语言版本正在翻译，请参阅<a href="#翻译用户指南">翻译用户指南</a>部分。</p>
</section>
<section id="简介" class="level2">
<h2 class="anchored" data-anchor-id="简介">简介</h2>
<p>Anki 是一个软件，它帮助你更高效的记忆。因为它比传统学习方法高效，所以可以为你节省大量学习时间，或在同样的学习时间掌握更多内容。</p>
<p>只要你需要记东西，Anki 就能帮到你。由于它对添加内容的格式不作限制，支持图片、音频、视频及文本标记语言（通过 LaTeX），所以其可能性取决于你的想象力。例如：</p>
<ul>
<li>学语言</li>
<li>备考医学及司法考试</li>
<li>记忆人名与面孔</li>
<li>复习地理</li>
<li>甚至练习吉他和弦！</li>
</ul>
<p>Anki 背后有两个简单的概念：<em>主动回忆测试（Active recall testing）</em>与<em>间隔重复（spaced repetition）</em>。尽管相关文献早已存在多年，但大多数学习者对此仍不甚了解。了解这些概念的底层逻辑，有助于你成为高效学习者。</p>
<section id="主动回忆测试" class="level3">
<h3 class="anchored" data-anchor-id="主动回忆测试">主动回忆测试</h3>
<p><em>主动回忆测试</em> 即学习后在特定时点刻意安排测试题目并努力回想。这与<em>被动学习（passive study）</em>有所差别，被动学习下，我们读、看或听，而不会停下来考虑是否记住了答案。研究表明，主动回忆测试在建立牢固记忆方面比被动学习更有效。有两个原因：</p>
<ul>
<li>回忆某事的行为<em>增强</em>了记忆力，增加了我们能够再次记住它的机会。</li>
<li>当我们无法回答题目时，则表明我们需要再次复习或重新学习。</li>
</ul>
<p>你在学校学习中或许遇到过主动回忆测试，却不曾察觉。在阅读一篇文章后，老师们布置相关作业，或安排周考，并不仅仅是为了看你是否理解所学。借由测试，还增加了你未来成功回想学习内容的可能性。</p>
<p>将主动回忆测试整合到你的学习中的好方法之一是使用抽认卡。使用传统的纸质抽认卡，你可以在卡片的一面写下题目，而在另一面写下答案。在你想到答案之前，不要把卡片翻过来，这样比被动学习更有效。</p>
</section>
<section id="用进废退" class="level3">
<h3 class="anchored" data-anchor-id="用进废退">用进废退</h3>
<p>人类大脑是极其高效的机器，它们迅速丢弃似乎无用的信息。你可能不记得两周前的周一晚餐吃过什么，因为这些信息通常无用。但如果你那天去了一家很棒的餐厅，并且在过去的两周里告诉人们它有多棒，这种情况下，你可能仍旧记得一清二楚。</p>
<p>大脑“用进废退”的工作规律适用于任何学习内容。如果你花了一下午记住一些学术术语，然后在两周内不闻不问，那么你可能会忘个精光。事实上，研究表明，我们会在 48 小时内忘记新学内容的 75％。当你需要学习大量内容时，这个结论尤其令人沮丧。</p>
<p>解决方案很简单却又老生常谈：<em>复习</em>。通过复习新学到的内容，我们可以有效改善遗忘。</p>
<p>唯一的问题是，传统的复习方法不切实际。如果你使用纸质抽认卡片，且只有 30 张卡片需要复习的情况下，查看所有卡片轻而易举，但要是增加到 300 或 3000 张，局面将迅速失控。</p>
</section>
<section id="间隔重复" class="level3">
<h3 class="anchored" data-anchor-id="间隔重复">间隔重复</h3>
<p><em>间隔效应</em>由一位德国心理学家在 1885 年提出。他观察到我们倾向于通过分散复习形成牢固记忆而非集中重复。自 20 世纪 30 年代以来，涌现了一些利用间隔效应来改善学习的建议，这就是所谓的<em>间隔重复</em>。</p>
<p>拿 1972 年来说，当时有一位德国科学家塞巴斯蒂安·莱特纳（Sebastian Leitner）推广了一种采用纸质卡片实现间隔重复的方法。将纸卡分装到一系列盒子，并根据每次复习表现将卡片移动到不同盒子，这样可以方便地粗略估计卡片掌握程度和再次复习时间。这个方法明显优于单盒卡片，并且已被抽认卡软件广泛借鉴。然而，这是一种相当粗糙的方法，因为它不能提供复习内容的明确日期，而且不能很好地处理不同难度的学习内容。</p>
<p>过去 30 年来最大的进展来自 SuperMemo 的作者，SuperMemo 是一个实现了间隔重复的付费抽认卡程序。SuperMemo 开创了一个系统，该系统追踪复习内容的理想时间，并根据用户的学习表现进行调整。</p>
<p>在 SuperMemo 的间隔重复系统中，每次回答题目时，你都被要求反馈一个记忆情况给程序——完全忘记／记错一部分／困难地想起／轻而易举等等。该程序使用上述反馈推算再次测试相应题目的最佳时间。每多一次成功回忆，记忆就会变得更牢固，复习之间的时间间隔也就越来越长——所以你可能会在第 1、3、15、45……天分别看到同一个题目。</p>
<p>这是一次学习革新，因为它意味着可以通过尽可能少的、必要的努力知晓并记住所学。 SuperMemo 的口号对此做了贴切的概括：间隔重复，让你忘记遗忘。</p>
</section>
<section id="为什么选择-anki" class="level3">
<h3 class="anchored" data-anchor-id="为什么选择-anki">为什么选择 Anki ？</h3>
<p>虽然不可否认 SuperMemo 在其领域影响巨大，但它也并非尽善尽美。该程序难以使用，故而饱受批评。它只能在 Windows 电脑上运行。还是专利软件，这意味着用户无法对其进行扩展或访问原始数据。虽然免费提供老古董版本，但对当前使用而言非常鸡肋。</p>
<p>Anki 解决了上述问题。Anki 在许多平台上都有免费的客户端，照顾了经费拮据的学生和老师。作为开源软件，用户贡献的附加组件库应有尽有。而且它是多平台的，运行在 Windows，Mac OSX，Linux / FreeBSD 和一些移动设备上，较 SuperMemo 更易于使用。</p>
<p>Anki 内部的间隔重复系统基于 SuperMemo 算法的旧版本 SM2。随后的版本努力提高点学习效率，但是代价是复杂性大大增加，并且更容易在实际使用中出现学习任务调度错误。有关于此更深入的讨论以及调度算法的差异，请参阅常见问题解答中的<a href="#Anki-采用了哪种间隔重复算法">相应部分</a>。</p>
</section>
</section>
<section id="核心术语" class="level2">
<h2 class="anchored" data-anchor-id="核心术语">核心术语</h2>
<section id="卡片cards" class="level3">
<h3 class="anchored" data-anchor-id="卡片cards">卡片（Cards）</h3>
<p>题目与答案成对即是卡片。它们通常以纸质抽认卡为载体，一面是题目，另一面是答案。 不同于实体卡查看答案时题目会被翻到另一面，在 Anki 中查看答案时，它还为你额外显示题目。例如，如果你正在学习基础化学，你可能会看到如下题目：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="an">Q:</span><span class="co"> Chemical symbol for oxygen?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>思考片刻之后，你认为答案是 O ，点击显示答案按钮，Anki 会为你显示如下内容：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="an">Q:</span><span class="co"> Chemical symbol for oxygen?</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="an">A:</span><span class="co"> O</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>比对答案，确定回答正确后，你可以将记忆牢固程度反馈给 Anki，它会据此安排复习时间。</p>
</section>
<section id="卡组decks" class="level3">
<h3 class="anchored" data-anchor-id="卡组decks">卡组（Decks）</h3>
<p>多卡成组。你可以将卡放置于不同卡组中，以部分学习你的卡片集合，而非一次学习所有。每个卡组均可单独设置，如每天展示多少张新卡，或再次展示卡片的时间。</p>
<p>卡组可以包含其它卡组，所以你可以将它们组织成树形结构。 Anki 使用“::”表示层级关系。名为“Chinese::Hanzi”的卡组指向“Hanzi”卡组，它是“Chinese”卡组的成员。 如果选择“Hanzi”卡组，则只展示“Hanzi”卡组中的卡片; 如果选择“Chinese”卡组，则“Chinese”卡组下所有卡片均会展示，包括“Hanzi”卡组中的卡片。</p>
<p>要创建卡组层级关系，可在命名卡组时，在卡组之间键入“::”，也可在卡组列表界面拖拽实现。从属于某卡组（即卡组名称中至少有一个“::”）的卡组称为子卡组，而顶层卡组则称为超卡组或父卡组。</p>
<p>Anki 启动后自带“default”卡组。出于某种原因落单的卡片将回到“default”卡组。如果“default”卡组中无卡片，且你添加了其他卡组，Anki 就会隐藏“default”卡组。或者，你也可以重命名此卡组另作它用。</p>
<p>卡组最好以宽泛的口径命名，而非“food verbs”或“lesson 1”这样的特定主题。若要了解更多信息，请参阅<a href="#恰当使用卡组">恰当使用卡组</a>部分。</p>
<p>有关卡组如何影响卡片展示顺序的信息，请参阅<a href="#展示顺序">展示顺序</a>部分。</p>
</section>
<section id="笔记与字段notes-fields" class="level3">
<h3 class="anchored" data-anchor-id="笔记与字段notes-fields">笔记与字段（Notes &amp; Fields）</h3>
<p>制作抽认卡时，通常需要制作多张与某些信息相关的卡片。例如，如果你正在学习法语，了解到“bonjour”这个词的意思是“hello”，可能就希望制作一张卡片，题目那一面写上“bonjour”，用来回想“hello”。另一张卡片题目一面则写上“hello”，用来回想“bonjour”。 前者测试你的外语词汇辨识能力，而后者测试你对关联词汇的联想能力。</p>
<p>当使用纸质抽认卡时，在这种情况下，唯一的选择是实打实的写两张卡，每张卡片一次。有些计算机抽认卡程序提供翻转正面和背面的功能让上述情况得以改善，但有两个严重缺点：</p>
<ul>
<li>因为这些程序没有为你分别跟踪辨识能力、联想能力的表现，卡片往往不会在最佳时间进行复习，这意味着你要么复习得不够要么学得太过。</li>
<li>只有需要卡片翻转后内容仍保持不变，翻转制卡才有意义。这意味着不可能在每张卡的背面显示额外的信息。</li>
</ul>
<p>假设我们想学习法语词汇，并希望在每张卡片的背面显示页码。即卡片如下所示：</p>
<pre class="markddown"><code>Q: Bonjour
A: Hello
   Page #12</code></pre>
<p>和</p>
<pre class="markddown"><code>Q: Bonjour
A: Hello
   Page #12</code></pre>
<p>在上例中，我们有三条关联信息：法文单词，英文含义和页码。如果我们把它们放在一起，他们看起来会像这样：</p>
<pre class="markddown"><code>French: Bonjour
English: Hello
Page: 12</code></pre>
<p>在 Anki 中，这种关联信息就是<em>笔记（note）</em>，每条信息则被视为一个<em>字段（field）</em>。所以我们可以说这种类型的笔记有三个字段：French、English 和 Page。</p>
<p>要添加和编辑字段，请在添加或编辑笔记时单击<code>Fields...</code>按钮。有关字段的更多信息，请参阅<a href="#定制字段">定制字段</a>部分。</p>
</section>
<section id="卡片类型card-types" class="level3">
<h3 class="anchored" data-anchor-id="卡片类型card-types">卡片类型（Card Types）</h3>
<p>要让 Anki 根据我们的笔记创建卡片，我们需要给它张设计图，指出应在每张卡片的正面或背面显示哪些字段。这张设计图被称为<em>卡片类型</em>。每种笔记类型可以有一种或多种卡片类型；当你添加一个笔记时，Anki 会为相应笔记类型下每种卡片类型创建一张卡片。</p>
<p>每种卡片类型都有两个模板，一个用于题目，一个用于答案。在上面的法语例子中，我们希望识别卡片看起来像这样：</p>
<pre class="markddown"><code>Q: Bonjour
A: Hello
   Page #12</code></pre>
<p>为此，我们需要将题目和答案模板设置为：</p>
<pre class="markddown"><code>Q: {{French}}
A: {{English}}&lt;br&gt;
   Page #{{Page}}</code></pre>
<p>通过双大括号包裹字段名称，我们告诉 Anki 为我们制卡时，用该字段名称代表的具体信息替换该双大括号及字段名称。没有被大括号包裹的任何信息在每张卡片上都保持一致。（例如，添加素材时，我们不必在 Page 字段中键入“Page #”——它会自动添加到每张卡片中。）<code>&lt;br&gt;</code>是一种特定代码，可以让 Anki 在该代码与其后内容中间插入空白行；更多详细信息可在<a href="#卡片与模板">模板</a>部分中找到。</p>
<p>以类似方式制作卡片模版：</p>
<pre class="markddown"><code>Q: {{English}}
A: {{French}}&lt;br&gt;
   Page #{{Page}}</code></pre>
<p>一旦创建卡片类型，每次添加新笔记，都将根据该卡片类型创建至少一张卡。卡片类型使得卡片版式一致性保持变得更轻松，并大大减少添加信息所需的工作量。同时有助于 Anki 确保相关卡片不会连续出现，并且允许你批量修复输入错误或事实型错误，并且一次性更新所有相关卡片。</p>
<p>要添加和编辑卡片类型，请在添加或编辑笔记时单击<code>Cards...</code>按钮。更多信息，请参阅<a href="#卡片与模板">卡片与模板</a>部分。</p>
</section>
<section id="笔记类型note-types" class="level3">
<h3 class="anchored" data-anchor-id="笔记类型note-types">笔记类型（Note Types）</h3>
<p>Anki 允许你为不同的素材创建不同类型的笔记。每种笔记类型都有自己的一组字段和卡片类型。为学习中的每个宽泛主题创建一个单独笔记类型，是一个好主意。在上面的法语例子中，我们可以为此创建一个名为“French”的笔记类型。如果我们想要记忆各国首都，我们也可以为此新建一个笔记类型，其中包含“Country”和“Capital”等字段。</p>
<p>Anki 只在同类型笔记中检查重复性。因此，如果你使用 capital city 笔记类型添加名为“Orange”的首都城市，那么在 French 笔记类型中学习如何用法语说“Orange”时，虽然首字段相同，但不会提示笔记存在重复。</p>
<p>创建新集合时，Anki 会自动为其添加一些标准笔记类型。提供这些笔记类型是为了让新用户更容易上手，但从长远来看，建议你还是为所学内容定制自己的笔记类型。标准笔记类型如下：</p>
<p><strong>Basic</strong> 拥有 Front 和 Back 字段，并将创建一张卡片。你在 Front 中输入的文字将显示在卡片的正面，在 Back 中输入的文字将显示在卡片的背面。</p>
<p><strong>Basic (and reversed card)</strong> 与 Basic 类似，但会为你输入的文本创建两张卡片：一张从正面 → 背面，另一张从背面 → 正面。</p>
<p><strong>Basic (optional reversed card)</strong> 创建一张从正面 → 背面的卡片，可有选择性的创建背面 → 正面的卡片。为了实现这一点，它还有第三个字段叫作“Add Reverse”。只要在该字段中输入任意文本，都将创建一个翻转卡。 更多信息，请参见<a href="#卡片与模板">卡片与模板</a>部分。</p>
<p><strong>Cloze</strong> 一种便于制作完形填空的笔记类型（例如，“人类在[…]登月” → “人类在 1969 年登月”）。更多信息，请参见<a href="#完形填空">完形填空</a>部分。</p>
<p>要添加自己的笔记类型和修改现有的笔记类型，您可以在 Anki 主界面使用命令菜单<code>Tools</code> → <code>Manage Note Types...</code>。</p>
<section id="注意" class="level4">
<h4 class="anchored" data-anchor-id="注意">注意</h4>
<blockquote class="blockquote">
<p>笔记和笔记类型在整个集合范围可见，而不限于单个卡组。这意味着你可以在特定的卡组中使用多种不同笔记类型，或者在不同的卡组中使用特定笔记生成不同卡片。使用“Add”界面添加笔记时，可选择笔记类型以及卡片要添加到的卡组，这些选项完全相互独立。你也可以在创建笔记后更改其笔记类型。</p>
</blockquote>
</section>
</section>
<section id="集合collection" class="level3">
<h3 class="anchored" data-anchor-id="集合collection">集合（Collection）</h3>
<p>你的<em>集合</em>囊括存放在 Anki 中的所有素材——卡片、笔记、卡组，笔记类型，卡组选项等等。</p>
</section>
</section>
<section id="添加学习内容" class="level2">
<h2 class="anchored" data-anchor-id="添加学习内容">添加学习内容</h2>
<section id="下载共享卡组" class="level3">
<h3 class="anchored" data-anchor-id="下载共享卡组">下载共享卡组</h3>
<p>你可以在 YouTube 上观看有关<a href="https://www.youtube.com/watch?v=QS2G-k2hQyg&amp;yt%3Acc=on">共享卡组与复习基本操作</a>的视频。</p>
<p>开始使用 Anki 最简单的方法是下载别人共享的卡组：</p>
<ol type="1">
<li>点击主界面卡组列表底部的<code>Get Shared</code>按钮。</li>
<li>当你发现你感兴趣的卡组时，点击<code>Download</code>按钮下载卡组文件包。</li>
<li>双击下载的文件包将其导入 Anki ，或者使用命令菜单<code>File</code> → <code>Import...</code> 导入。</li>
</ol>
<p>请注意，目前无法将共享卡组直接添加到你的 AnkiWeb 帐户。你需要使用 PC 版 Anki 导入它们，然后同步以将其上传到 AnkiWeb。</p>
<p>有关如何与他人分享你的卡组，请参阅<a href="#分享卡组">分享卡组</a>。</p>
<section id="自制与预制" class="level4">
<h4 class="anchored" data-anchor-id="自制与预制">自制与预制</h4>
<p>自制卡组是学习复杂主题最有效的方法。像语言和科学这样的主题不能简单地通过记忆事实来理解——它们需要阐释及背景知识才能有效地学习。此外，自己输入信息会迫使你识别个中关键，从而深入理解。</p>
<p>如果你在学一门语言，你可能会试图下载一堆单词及释义，但这对于真正掌握一门语言毫无裨益，好比通过死记公式掌握天体物理学。想要学有所得，你需要教科书、老师或反复操练真实语境下的句子。</p>
<pre class="markddown"><code>Do not learn if you do not understand.
--SuperMemo</code></pre>
<p>大多数共享卡组由人们创建自 Anki 之外的学习素材——课本、课程、电视等等。人们从学到的东西中选择有趣的点，并放入 Anki。他们不会为卡片添加背景知识或解释，因为他们已经理解了这些素材。所以当别人下载他们的卡组并尝试使用时，会觉得晦涩难懂，因为缺少背景知识和解释。</p>
<p>这并不是说共享卡组没用——简单地说，对于复杂的主题，卡组应该用作 Anki 外学习素材的补充，而不是作为其替代品。如果你正在学习教材 ABC，并且有人分享了取材自教材 ABC 的卡组，那么直接拿来参考，节省一些时间想必是极好的。对于基本上是事实清单的简单主题，例如首都城市名称或酒吧竞猜之类，外部素材就没啥必要了。但如果你试图在没有外部素材的情况下，直接用 Anki 卡组学习复杂主题，就等着失望透顶吧。</p>
</section>
</section>
<section id="添加卡片与笔记" class="level3">
<h3 class="anchored" data-anchor-id="添加卡片与笔记">添加卡片与笔记</h3>
<p>如<a href="#核心术语">核心术语</a>部分所说，我们在 Anki 中添加笔记而非卡片，Anki 利用笔记为我们创建卡片。在 Anki 主界面中单击<code>Add</code>，然后将出现添加笔记界面。</p>
<p>界面左上角显示当前笔记类型。 如果不是“Basic”，那么可能是由于你导入的共享卡组，引入了某些笔记类型。下文假设选择的是“Basic”。</p>
<p>界面右上方显示卡片要添加到的卡组。如果你想将卡片添加到新卡组，可以点击卡组名称，然后点击<code>Add</code>。</p>
<p>在笔记类型下方，你会看到一些按钮以及标注“Front”和“Back”的区域。Front 和 Back 被称为字段，你可以通过单击其上方的<code>Fields...</code>按钮来添加，删除和重命名它们。</p>
<p>字段下方是一个标有“Tags”的区域。 Tags 是可以附加到笔记的标签，使组织和查找笔记更加轻松。可留空，或添加一个或多个标签。标签由空格分隔。若标签区域是：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>vocab check_with_tutor</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>那么该笔记添加后会有“vocab”与“check_with_tutor”两个标签。</p>
<p>在相应字段填写完成后，可以单击<code>Add</code>按钮或按<code>Ctrl</code> + <code>Enter</code>（Mac 上的<code>Command</code> + <code>Enter</code>）将笔记添加到你的集合。与此同时，会根据笔记创建对应卡片，并放入你选择的卡组中。若想编辑方才添加的卡片，可以在 <a href="#浏览器">Browser</a> 界面单击<code>Added Today</code>按钮筛出刚刚添加的卡片。</p>
<p>Anki 会检查笔记首字段的唯一性，所以如果输入第二条首字段也是“apple”的笔记，Anki 会发出警告。唯一性检查仅在当前笔记类型进行，因此如果你正在学习多种语言，要避免相同首字段的笔记的被判定为重复，最好为每种语言设置不同笔类型。</p>
<p>出于性能考虑，Anki 不会自动检查其他字段来识别重复项，但在 Browser 界面可通过<code>Edit</code> → <code>Find Duplicates</code>，定期手动执行一个字段及以上的重复项检查。</p>
<p>有关笔记类型和字段之间的按钮的更多信息，请参阅<a href="#编辑">编辑器</a>部分。</p>
<p>不同的人喜欢以不同的方式进行复习，但某些通用规则有必要牢记心中。 SuperMemo 网站上的<a href="https://www.supermemo.com/en/articles/20rules">这篇文章</a>对此做了极好的介绍。 尤其是：</p>
<section id="最佳实践" class="level4">
<h4 class="anchored" data-anchor-id="最佳实践">最佳实践</h4>
<ul>
<li><strong>保持简洁</strong>：卡片越简短，它们就越容易复习。为了有备无患，你可能忍不住往卡片里堆砌大量信息，但复习起来就会举步维艰。</li>
<li><strong>切忌不加理解死记硬背</strong>：如果你正在学习一门语言，应尽量避免背词典式单词学习。学习语言的最佳方式是沉浸在真实语境中，这意味着去揣摩用那些句子中的词汇。同样，想象你正在学习计算机课程。如果你试图直接记住成堆缩略词，将难有寸进。但是如果你花时间理解缩略词背后的含义，学习缩略词会变得容易很多。</li>
</ul>
</section>
</section>
<section id="添加笔记类型" class="level3">
<h3 class="anchored" data-anchor-id="添加笔记类型">添加笔记类型</h3>
<p>制作每面只有词或短语的简单卡片，basic 笔记类型绰绰有余，但当你想在卡片某一面放置多条信息，最好将信息成拆分到不同字段。</p>
<p>你可能会想“哼！我只想要一张卡片，为什么我就不能往 Front 字段里扔音频、图片、提示和翻译？” 你要喜欢这么做，那也行。但这种方法的缺点是所有的信息都混在一起。如果你想按照提示将卡片排序，那是不可能的。除了傻傻地逐个复制和粘贴，批量将音频从卡片正面移动到后面也是不可能的。将相对独立的内容，分置于不同字段，将来调整卡片版式就轻松啦。</p>
<p>要创建新笔记类型，请从 Anki 主界面中选择<code>Tools</code> → <code>Manage Note Types</code>。然后点击“Add”添加新笔记类型。你会看到另一个界面，供你基于当前可用笔记类型新建笔记类型。选择“Add”开头的会让新建类型基于 Anki 自带标准笔记类型。选择“Clone”开头的会让新建类型以存在于你集合中的笔记类型为母版。例如，如果你已经创建了一个 French Vocab 笔记类型，当创建同为语言类笔记的 German Vocab 笔记类型时，你可能会去克隆前者。</p>
<p>选择<code>OK</code>后，需要你为新建的类型取个名字。使用所学素材的科目名称是个好注意——诸如“Japanese”，“Trivia”等。命名后，关闭“Note Types”界面，你会回到 Anki 主界面。</p>
</section>
<section id="定制字段" class="level3">
<h3 class="anchored" data-anchor-id="定制字段">定制字段</h3>
<p>要定制字段，请在添加或编辑笔记时或在“Manage Note Types”界面中选择笔记类型时单击<code>Fields...</code>按钮，你将看到“+ Fields for …”界面（某种笔记类型的字段编辑界面）。</p>
<p>你可以单击相应的按钮来添加，删除或重命名字段。要调整字段编辑界面和添加笔记界面字段的显示顺序，你可以使用<code>Repositon</code>按钮。点击该按钮后，会询问你想把相应字段调整到第几位。如果你想将某字段调整到第一位，请输入“1”。</p>
<section id="注意-1" class="level4">
<h4 class="anchored" data-anchor-id="注意-1">注意</h4>
<blockquote class="blockquote">
<p>不要使用 <em>Tags</em>、<em>Type</em>、<em>Deck</em>、<em>Card</em> 或 <em>FrontSide</em> 作为字段名称，因为它们是专用字段，无法正常工作。</p>
</blockquote>
<p>屏幕底部的选项可供你在添加、编辑卡笔记，为字段设置各种特性。此处并非用来定制复习时的卡片样式; 了解定制卡片样式，请参阅<a href="#卡片与模板">模板</a>。</p>
<p><strong>Editing Font</strong> 用来设置编辑笔记时使用的字体和大小。 如果希望缩小不重要的信息，或者放大难以阅读的外文字符，这非常实用。此处所做的更改不会影响复习时的卡片样式：了解定制卡片样式，请参阅<a href="#卡片与模板">模板</a>。但是，如果你启用了“type in the answer”（在答案中输入）功能，则你输入的文本将使用此处设置的字体大小。（有关如何在输入答案时更改实际字体的信息，请参阅<a href="#比对答案部分">比对答案部分</a>。）</p>
<p><strong>Sort by this field…</strong> 让 Anki 将某字段用作 Browser 界面的“Sort Field”列（排序字段）。 借此，你可以按上述字段对卡片进行排序。一次只能设置一个字段为“Sort Field”。</p>
<p>当 <strong>Remember last input…</strong> 时，Anki 在添加笔记后不会清除该字段的内容。若需要在多个笔记中输入相同内容，这个特性就蛮实用哒。</p>
<p>如果你正在学习从右向左（RTL）书写的语言（如阿拉伯语或希伯来语），那么 <strong>Reverse text direction</strong> 就很有用。此设置目前仅作用于编辑; 为确保复习卡片时正确排列文字，需要调整你的<a href="#卡片与模板">模板</a>。</p>
<p>添加字段后，你可能需要将它们添加到卡片的正面或背面。欲知详情，请参阅<a href="#卡片与模板">模板</a>部分。</p>
</section>
</section>
<section id="更改卡组或笔记类型" class="level3">
<h3 class="anchored" data-anchor-id="更改卡组或笔记类型">更改卡组或笔记类型</h3>
<p>在 Add 界面，你可以点击左上角的按钮更改笔记类型，右上角的按钮可以更改卡组。 打开的窗口不仅可以选择卡组或笔记类型，还可以添加新的卡组或管理笔记事类型。</p>
</section>
<section id="恰当使用卡组" class="level3">
<h3 class="anchored" data-anchor-id="恰当使用卡组">恰当使用卡组</h3>
<p>卡组被设计用来将学习内容分成你要单独学习的大类，如 English、Geography 等。你可能会创建大量小卡组以使内容条理分明，例如“my geography book chapter 1”或“food verbs”，但不建议这样做，原因如下：</p>
<ul>
<li>大量小卡组意味着你最终会以可辨认的顺序复习卡片。不管是依次点击每个卡组（这样很低效），还是在某个父卡组下添加了一堆子卡组，最终所有的“chapter 1”或“food verb”卡片会连续出现。这样回答卡片更容易，就像你可以从上下文中猜出它们一样，这样的记忆并不牢固。当你需要在 Anki 外回想单词或短语时，第一时间记起相关内容将是一种奢望！</li>
<li>Anki 并不是用来处理大量卡组的（超过几十个），随着卡组数量增加，它会变得越来越慢——尤其是在移动客户端上。额外创建几个卡组不会有明显感觉，但如果卡组太多，延迟会越发明显。</li>
</ul>
<p>组合或单独使用标签字段以分类内容更值得推荐，而非创建大量小卡组。例如，你可以将“food verbs”之类的卡片添加到你的语言学习卡组中，并用“food”（食物）和“verb”（动词）标记卡片，而非创建“food verbs”卡组。每张卡可以有多个标签，让你可以搜索所有动词，或者所有与食物有关的词汇，或者所有与食物有关的动词。</p>
<p>对于那些有强迫症的用户，你可以在笔记添加分类字段，例如“book”、“page”等。 Anki 支持在特定字段中搜索，这意味着你可以使用“book:‘my book’ page:63”这样的模式在 Browser 中检索 book 字段为 my book，page 字段为 63 的卡片。（译注：如上模式在 Browser 若要使用模糊查找，需要结合通配符。）</p>
<p>Anki 的<a href="#筛选卡组与临阵磨枪">定制学习和筛选卡组</a>功能使其尤为强大，因其让你可以使用搜索结果创建临时卡组。这样你就可以在一个卡组中复习多主题混合内容（为了获得最佳记忆效果），还可以在需要专注于特定材料（如测试前）时创建临时卡组。简而言之，如果你经常单独学习某些内容，对应卡片应置于某个卡组中，如果只是偶尔单独学习这些内容（由于测试、压力等），则更适合使用标签/字段筛选卡组。</p>
</section>
</section>
<section id="学习" class="level2">
<h2 class="anchored" data-anchor-id="学习">学习</h2>
<p>当你找到感兴趣的卡组或在 Anki 中输入了笔记，就可以着手开始学习。</p>
<section id="卡组" class="level3">
<h3 class="anchored" data-anchor-id="卡组">卡组</h3>
<p>每次学习，将在你选定的卡组及其子卡组中进行。</p>
<p>在卡组界面，你的卡组会以列表形式呈现。其中有两列数字——<em>Due</em> 和 <em>New</em>。<em>Due</em> 是正在学习的卡片中，需在当天复习的卡片数量。<em>New</em> 则是需当天新学的卡片数量。</p>
<p>当你点击某一卡组名称，该卡组就会成为<em>当前卡组（current deck）</em>，接着 Anki 会切换到学习概览界面。你可以在任何时候切回卡组列表，以更改<em>当前卡组</em>，只需要点击主界面顶部的<code>Decks</code>按钮。（你也可以使用<a href="#快捷键">Study Deck</a>）功能，利用快捷键选择新卡组，或在学习概览界面按下<code>s</code>键进入当前选中卡组学习。</p>
<p>你可以点击卡组列表界面最右侧的齿轮按钮，重命名、删除、<a href="#导出">导出卡组</a>或更改卡组选项。</p>
</section>
<section id="学习概览" class="level3">
<h3 class="anchored" data-anchor-id="学习概览">学习概览</h3>
<p>点击卡组后，将有一个界面向你展示今日到期卡片数。这就是所谓的<em>卡组概览界面（deck overview screen）</em>在这里，卡片被分为三种类型：</p>
<ul>
<li><strong>New</strong> 指的是那些你下载导入或自行键入，但从未学习过的卡片。</li>
<li><strong>Learning</strong> 指的是那些最近首次看到，且学习中的卡片。</li>
<li><strong>To Review</strong> 指的是以前学过的卡片，需要现在复习，以免忘记。</li>
</ul>
<p>点击<code>Study Now</code>按钮，进入学习界面。Anki 接着会向你依次展示卡片，直至当天卡片展示完毕。</p>
<p>学习时，你可以按下<code>s</code>键回到学习概览界面。</p>
</section>
<section id="题目" class="level3">
<h3 class="anchored" data-anchor-id="题目">题目</h3>
<p>显示卡片时，首先只显示题目。想想答案后，请单击<code>Show Answer</code>按钮或按空格键以显示答案。花一点时间回忆答案也没关系，但一般来说，如果你在 10 秒内不能回答，最好放弃并查看答案，而不是挣扎回想。</p>
<p>当显示答案时，你应该对比刚想到的答案与显示的答案，并告诉 Anki 你记得怎么样。如果你不相信自己能够准确地比较答案，你可以要求 Anki <a href="#核查你的答案">提示你键入答案</a>，而不是仅仅向你显示答案。</p>
<p>可用于评分的按钮数量取决于卡片是否正在学习或复习。</p>
</section>
<section id="学习-1" class="level3">
<h3 class="anchored" data-anchor-id="学习-1">学习</h3>
<p>学习新卡片时，或者复习遗忘记卡片时，Anki 会一次或多次向你展示卡片以帮助你记忆卡片。每一次都被称为一个<em>学习步骤（learning step）</em>。默认设置有两个步骤：1 分钟和 10 分钟。你可以在<a href="#卡组选项">卡组选项</a>中更改步骤数和它们之间的间隔时间。</p>
<p>学习时有三个评价按钮：</p>
<p><strong>Again</strong> 移动卡片回到第一个学习步骤。</p>
<p><strong>Good</strong> 将卡片移到下一学习步骤。如果卡片已在最后一个学习步骤，点击 Good，该卡片将被转换成复习卡（它<em>毕业</em>了）。默认情况下，一旦卡片走完所有学习步骤，卡片将在第二天再次展示，然后以越来越长的间隔显示（见下一部分）。</p>
<p><strong>Easy</strong> 将忽略该卡片未完成的学习步骤，立即将卡转换为复习卡片。默认情况下，该卡将在 4 天后再次显示，之后再次显示的间隔时间越来越长。如果你处于复习模式，<code>easy</code>按钮将不会显示，但会给<code>good</code>按钮 4 天的间隔。</p>
<p>当首次看到卡片时，其处于第一步。这意味着此时点按<code>Good</code>，将会让卡片在 10 分钟内再次显示，最初的 1 分钟步骤将被跳过。但如果你此时按的是<code>Again</code>，卡片则将在 1 分内再次显示。</p>
<p>你可以使用键盘上的<code>1</code>，<code>2</code>和<code>3</code>键选择上述按钮，其中<code>1</code>是<code>Again</code>。按空格键将选择<code>Good</code>。</p>
<p>如无卡可学，Anki 将再次显示学习中的卡片，即使它们还未到期。如果你希望严格按期学习，可在<a href="#偏好设置">偏好设置</a>中调整。</p>
</section>
<section id="复习" class="level3">
<h3 class="anchored" data-anchor-id="复习">复习</h3>
<p>当一张卡完成了学习阶段且进行复习时，有四个按钮可以评价你的回答：</p>
<p><strong>Again</strong> 告诉 Anki 你认为自己回答错了，并要求 Anki 往后更频繁地出示该卡。 这就是所谓的失误卡。请参阅<a href="#失误">失误</a>部分以获取有关失误卡复习如何处理的更多信息。</p>
<p><strong>Hard</strong> 让卡片下次显示的间隔时间较上次略长，且要求 Anki 往后更频繁地显示该卡。</p>
<p><strong>Good</strong> 告诉 Anki 当前的复习节奏比较恰当，且卡片的容易度不需要调整。在默认容易度下，卡片再次显示的时间将是上一次的 2.5 倍，因此如果你之前等待了 10 天才能看到卡片，则下一次延迟时间将约为 25 天。</p>
<p><strong>Easy</strong> 告诉 Anki 你感觉复习过于频繁。那么该卡片就会被安排一个比<em>Good</em>更慢的复习节奏，Anki 会降低该卡显示频率。因为<em>Easy</em>可以快速增加卡片复习间隔，所以最好只用于最简单的卡片。通常而言，回答<em>Good</em>才是上策。</p>
<p>与学习卡片时一样，你可以使用键盘上的<code>1</code>-<code>4</code>来选择答案。按空格键将选择<code>Good</code>。</p>
</section>
<section id="到期计数和时间估计" class="level3">
<h3 class="anchored" data-anchor-id="到期计数和时间估计">到期计数和时间估计</h3>
<p>当只有题目显示时，Anki 在软件界面底部显示三个数字：12 + 34 + 56。分别代表：今日待新学卡片数、今日学习中卡片数和今日待复习的卡片数。如果你不想看到这些东东，你可以在 Anki 偏好设置中关闭它们。</p>
<section id="注意-2" class="level4">
<h4 class="anchored" data-anchor-id="注意-2">注意</h4>
<blockquote class="blockquote">
<p>今日需要复习的卡片计数，计算的是今日需复习的卡片队列中的卡片数量，而不是<em>卡组</em>中的卡片数量。如果你为失误卡设置了多个复习步骤，那么当你反馈一张失误卡后，今日需要复习的卡片数随后至少会增加 1 次以上。因为这张失误卡需要在今日复习过程中多次展示。</p>
</blockquote>
<p>当答案被展示时，Anki 会在软件界面底部的每个按钮上提示：若按下该按钮，当前卡片下一次展示的时间估计。如果你不想看到这些时间估计，你可以在 Anki 的首选项中禁用它们。</p>
</section>
<section id="注意-3" class="level4">
<h4 class="anchored" data-anchor-id="注意-3">注意</h4>
<blockquote class="blockquote">
<p>另外，Anki 为卡片到期复习时间计算添加了微小的随机变化，以避免在未来复习时，经常在同一天复习大量同时进入学习且学习反馈一致的卡片。这种随机变化在时间估计上没有体现，但在选择按钮之后将被应用。</p>
</blockquote>
</section>
</section>
<section id="编辑及更多" class="level3">
<h3 class="anchored" data-anchor-id="编辑及更多">编辑及更多</h3>
<p>您可以学习过程中，单击界面左下角的<code>Edit</code>按钮编辑当前展示卡片所归属的笔记。当你完成编辑后，你将返回学习界面。编辑界面非常类似于<a href="#添加卡片与笔记">添加笔记</a>界面。</p>
<p>在复习界面的右下角是一个标注为<code>More</code>的按钮。这个按钮供你在当前卡或笔记上做其他操作：</p>
<p><strong>Mark Note</strong> 将一个“marked”标签添加到当前卡片，以便在 Browser 快速查找。对于某些想要稍后处理对卡片，这个功能相当实用，如回家后查询一个单词。复习时，被标记的卡片左上角将显示一个小星星。</p>
<p><strong>Bury Card / Note</strong> 将待复习的卡片或笔记派生的卡片<strong>搁置</strong>到明天。（如果想在搁置到期日之前取消搁置，你可以在<a href="#学习概览">卡组概览</a>界面点按<code>Unbury</code>按钮。）这个功能相当不错，尤其是在你当前无法回答或想稍后回答时。对于派生自同一笔记的卡片，时有<a href="#姊妹与搁置">自动搁置</a>。学习中的卡片被搁置前，将先行移去待新学卡片队列或待复习卡片队列。</p>
<p><strong>Suspend Card / Note</strong> <strong>暂停</strong>待复习的卡片或笔记派生的卡片直至手动取消暂停（点按 Browser 界面中的 <code>Suspend</code>按钮）。当你不想复习某些内容一阵子，但又不想删除它们时，这个功能比较实用。学习中的卡片被暂停前，将先移去待新学卡片队列或待复习卡片队列。</p>
<p><strong>Delete Note</strong> 删除笔记及其派生的卡片。</p>
<p><strong>Options</strong> 编辑当前卡组选项。</p>
<p><strong>Replay Audio</strong> 如果卡片正面或背面有录音，再次播放。</p>
<p><strong>Record Own Voice</strong> 从麦克风录音，用以检查对比你的发音。这个录音时是临时的，当你学习下一张卡片时，这个录音也会随风飘逝。如果你想为一张卡片添加永久的录音，请使用编辑界面。</p>
<p><strong>Replay Own Voice</strong> 再次播放前文所述你的录音（一般是在展示答案后）。</p>
</section>
<section id="展示顺序" class="level3">
<h3 class="anchored" data-anchor-id="展示顺序">展示顺序</h3>
<p>学习过程中展示的卡片来自选择的卡组及其子卡组。因此，如果你选择了你的“French”卡组，子卡组“French::Vocab”、”French::My Textbook“及”French::Lesson 1“中的卡片也会在出现在学习过程中。</p>
<p>Anki 按照卡组名称的字母顺序从卡组中取出新卡片和复习卡片。所以在上述的例子中，你将先看到来自“French”卡组的卡片，然后是“My Textbook”，最后是“Vocab”。你可以利用这一点控制卡片展示顺序，将重要的卡片置入展示优先级更高的卡组中。当电脑对卡组名字按字母顺序排序时，“-”符号会排在所有字母之前，而“～”则排在排在所有字母之后。所以你可以将前文“Voacb”卡组改名为“-Vocab”，让该卡组中的卡片首先展现。当然你也可以将“My Textbook”卡组改名叫“～My Textbook”强制其中卡片最后出现。</p>
<p>新卡片和复习卡片是分别取出的，且 Anki 不会等某一卡组的新卡队列、复习卡队列都空了才去下一卡组取出卡片。所以你可能会遇到这样的情况：复习甲卡组卡片期间，看到乙卡组的新卡片，反之亦然。如果你不喜欢这样，请直接点击首先想要复习的卡组，而不是点击该卡组的父卡组。</p>
<p>由于学习中的卡片时效更重要，所以会从所有卡组中一次性取出，并按照到期先后排序。</p>
<p>控制指定卡组复习卡片队列顺序，或将待新学卡片从顺序更改为乱序，请查阅<a href="#卡组选项">卡组选项</a>。如果想要更细腻的新卡排序，你可以在 <a href="#Browser">Browser</a> 中改变排序。</p>
</section>
<section id="姊妹卡与搁置" class="level3">
<h3 class="anchored" data-anchor-id="姊妹卡与搁置">姊妹卡与搁置</h3>
<p>如前文<a href="#核心术语">核心术语</a>所述，Anki 能够根据你提供的笔记创建至少 1 张卡片。比如根据笔记，同时创建 1 张正面➡背面的卡片和一张背面➡正面的卡片，或根据同一题目创建不同的完形填空卡片。这些由同一笔记派生的关联卡片称之为<em>姊妹卡（siblings）</em>。Anki 尽量避免姊妹卡扎堆展示，因为扎堆展示通常会给出下一卡片的答案，干扰真实记忆效果。</p>
<p>当你回答的卡片有姊妹卡时，Anki 会通过自动搁置这张卡片的姊妹卡，以阻止它们在本次学习中出现。搁置卡片将从复习队列消失直至明天，你也可以点按<a href="#学习概览">卡组概览</a>界面底部的<code>Unbury</code>按钮手动取消搁置。即使姊妹卡不在同一卡组，Anki 也会自动搁置它们。（姊妹卡不在同一卡组，通常是由于你使用了<a href="#卡组覆盖">卡组覆盖</a>功能。）</p>
<p>Anki 只会自动搁置新卡及复习卡的姊妹卡，而不会自动搁置学习中的卡片，因为确保它们的学习间隔更为重要。另一方面，当你有一张学习中的卡片时，该卡的其他新的、待复习的姊妹卡片都会被搁置。</p>
<p>如果你想在学习或复习卡片时，看到某一笔记派生的多张卡片，你可以在<a href="#卡组选项">卡组选项</a>中禁用自动搁置。</p>
</section>
<section id="快捷键" class="level3">
<h3 class="anchored" data-anchor-id="快捷键">快捷键</h3>
<p>Anki 中的大多数常用操作都有快捷键。其中大多数可以在软件界面中找到：菜单项在自身旁边列出了快捷方式，将鼠标箭头悬停在按钮上通常会在工具提示气泡中显示快捷方式。</p>
<p>学习时，无论是空格还是回车键都会展示答案。展示答案时，你可以使用空格或回车键以选择<code>Good</code>按钮。你可以使用 <code>1</code>-<code>4</code> 键选择特定的反馈按钮。许多人发现回答大多数卡片只需要一个手指放在空格间、一个手指放在 1 建（反馈那些遗忘的卡片）。</p>
<p><code>Tool</code>菜单中的<code>Study Deck</code>项可以让你通过键盘迅速切换到一个卡组。你可以用英文状态下的<code>/</code>键触发它。触发后，将显示所有的卡组，并在顶部显示过滤器区域。当你键入字符时，Anki 将只显示与你键入的字符匹配的卡组。你可以添加可歌来分隔多个搜索项，而 Anki 将只显示与所有项匹配的表。因此，“ja 1”或“on1 ja”都可以匹配一个名为“Japanese::Lesson1的卡组。</p>
</section>
<section id="滞后" class="level3">
<h3 class="anchored" data-anchor-id="滞后">滞后</h3>
<p>如果你在复习中滞后了，Anki 会优先考虑那些等待最长时间的卡片。它将等待时间最长的 200 张卡片随机地显示给您，直到你的每日复习上限为止。这种复习排序确保没有卡片会无限期地等待，但也意味着，如果你学习了新卡，那么它们得直到你清完旧账才能复习。</p>
<p>如果你希望更改逾期复习卡片的顺序，可以通过创建<a href="#筛选卡组与临阵磨枪">筛选卡组</a>实现。</p>
<p>当你回答已经等待了一段时间的卡片时，Anki 会在计算下次显示这些卡片的时间时考虑该延迟因素。请参阅 Anki 的间隔重复<a href="#Anki采用了哪种间隔重复算法？">算法</a>部分以获得更多信息。</p>
<p><br> 🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶</p>
<p>其他部分，🐢速翻译中……</p>
<p>🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶</p>
</section>
</section>
<section id="change-log" class="level2">
<h2 class="anchored" data-anchor-id="change-log">Change Log</h2>
<ul>
<li>20180902
<ul>
<li>Studying</li>
</ul></li>
<li>20180421
<ul>
<li>Adding Material</li>
</ul></li>
<li>20180417
<ul>
<li>The Basics</li>
</ul></li>
<li>20180416
<ul>
<li>Intro Videos</li>
<li>Translations</li>
<li>Introduction</li>
</ul></li>
</ul>
</section>
<section id="许可声明" class="level2">
<h2 class="anchored" data-anchor-id="许可声明">许可声明</h2>
<p>本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>


</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>